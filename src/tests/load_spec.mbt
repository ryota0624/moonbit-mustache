// spec of mustache

///|
priv struct Spec {
  tests : Array[SpecTest]
} derive(Eq, Show, ToJson, FromJson)

// spec test for mustache

///|
priv struct SpecTest {
  name : String
  desc : String
  template : String
  expected : String
  data : Json
} derive(Eq, Show, ToJson, FromJson)

///|
fn load_spec(path : String) -> Spec raise {
  let file = read_file(path)
  parse_file_to_spec(file)
}

///|
fn parse_file_to_spec(file : String) -> Spec raise {
  let json = @json.parse(file)
  let tests = try? {
      let specsJson = json
        .value("tests")
        .or_error(Failure("Missing 'tests' field in spec"))
      let specsArray = specsJson
        .as_array()
        .or_error(Failure("Expected 'tests' to be an array"))
      let specs = specsArray.map(fn(item : Json) -> SpecTest raise Failure {
        let itemObj = item
          .as_object()
          .or_error(Failure("Expected each test item to be an object"))
        {
          name: itemObj
          .get("name")
          .bind(t => t.as_string())
          .or_error(Failure("Missing 'name' field in test")),
          desc: itemObj
          .get("desc")
          .bind(t => t.as_string())
          .or_error(Failure("Missing 'desc' field in test")),
          template: itemObj
          .get("template")
          .bind(t => t.as_string())
          .or_error(Failure("Missing 'template' field in test")),
          expected: itemObj
          .get("expected")
          .bind(t => t.as_string())
          .or_error(Failure("Missing 'expected' field in test")),
          data: itemObj
          .get("data")
          .or_error(Failure("Missing 'data' field in test")),
        }
      })
      { tests: specs }
    }
  tests.unwrap_or_error()
}

///|
test "parse_file_to_spec" {
  let file =
    #|	{
    #|  "__ATTN__": "Do not edit this file; changes belong in the appropriate YAML file.",
    #|  "overview": "Comment tags represent content that should never appear in the resulting\noutput.\n\nThe tag's content may contain any substring (including newlines) EXCEPT the\nclosing delimiter.\n\nComment tags SHOULD be treated as standalone when appropriate.\n",
    #|  "tests": [
    #|    {
    #|      "name": "Inline",
    #|      "desc": "Comment blocks should be removed from the template.",
    #|      "data": {
    #|      },
    #|      "template": "12345{{! Comment Block! }}67890",
    #|      "expected": "1234567890"
    #|    },
    #|    {
    #|      "name": "Multiline",
    #|      "desc": "Multiline comments should be permitted.",
    #|      "data": {
    #|      },
    #|      "template": "12345{{!\n  This is a\n  multi-line comment...\n}}67890\n",
    #|      "expected": "1234567890\n"
    #|    },
    #|    {
    #|      "name": "Standalone",
    #|      "desc": "All standalone comment lines should be removed.",
    #|      "data": {
    #|      },
    #|      "template": "Begin.\n{{! Comment Block! }}\nEnd.\n",
    #|      "expected": "Begin.\nEnd.\n"
    #|    },
    #|    {
    #|      "name": "Indented Standalone",
    #|      "desc": "All standalone comment lines should be removed.",
    #|      "data": {
    #|      },
    #|      "template": "Begin.\n  {{! Indented Comment Block! }}\nEnd.\n",
    #|      "expected": "Begin.\nEnd.\n"
    #|    },
    #|    {
    #|      "name": "Standalone Line Endings",
    #|      "desc": "\"\\r\\n\" should be considered a newline for standalone tags.",
    #|      "data": {
    #|      },
    #|      "template": "|\r\n{{! Standalone Comment }}\r\n|",
    #|      "expected": "|\r\n|"
    #|    },
    #|    {
    #|      "name": "Standalone Without Previous Line",
    #|      "desc": "Standalone tags should not require a newline to precede them.",
    #|      "data": {
    #|      },
    #|      "template": "  {{! I'm Still Standalone }}\n!",
    #|      "expected": "!"
    #|    },
    #|    {
    #|      "name": "Standalone Without Newline",
    #|      "desc": "Standalone tags should not require a newline to follow them.",
    #|      "data": {
    #|      },
    #|      "template": "!\n  {{! I'm Still Standalone }}",
    #|      "expected": "!\n"
    #|    },
    #|    {
    #|      "name": "Multiline Standalone",
    #|      "desc": "All standalone comment lines should be removed.",
    #|      "data": {
    #|      },
    #|      "template": "Begin.\n{{!\nSomething's going on here...\n}}\nEnd.\n",
    #|      "expected": "Begin.\nEnd.\n"
    #|    },
    #|    {
    #|      "name": "Indented Multiline Standalone",
    #|      "desc": "All standalone comment lines should be removed.",
    #|      "data": {
    #|      },
    #|      "template": "Begin.\n  {{!\n    Something's going on here...\n  }}\nEnd.\n",
    #|      "expected": "Begin.\nEnd.\n"
    #|    },
    #|    {
    #|      "name": "Indented Inline",
    #|      "desc": "Inline comments should not strip whitespace",
    #|      "data": {
    #|      },
    #|      "template": "  12 {{! 34 }}\n",
    #|      "expected": "  12 \n"
    #|    },
    #|    {
    #|      "name": "Surrounding Whitespace",
    #|      "desc": "Comment removal should preserve surrounding whitespace.",
    #|      "data": {
    #|      },
    #|      "template": "12345 {{! Comment Block! }} 67890",
    #|      "expected": "12345  67890"
    #|    },
    #|    {
    #|      "name": "Variable Name Collision",
    #|      "desc": "Comments must never render, even if variable with same name exists.",
    #|      "data": {
    #|        "! comment": 1,
    #|        "! comment ": 2,
    #|        "!comment": 3,
    #|        "comment": 4
    #|      },
    #|      "template": "comments never show: >{{! comment }}<",
    #|      "expected": "comments never show: ><"
    #|    }
    #|  ]
    #|}
  let spec = parse_file_to_spec(file)

}

///|
extern "js" fn read_file(path : String) -> String = "moonbit:fs.read_file"
