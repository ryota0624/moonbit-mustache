// spec of mustache

///|
struct SpecFile {
  name : String
  spec : Spec
} derive(Eq, Show, ToJson, FromJson)

///|
priv struct Spec {
  tests : Array[SpecTest]
} derive(Eq, Show, ToJson, FromJson)

// spec test for mustache

///|
priv struct SpecTest {
  name : String
  desc : String
  template : String
  expected : String
  data : Json
} derive(Eq, Show, ToJson, FromJson)

///|
fn parse_file_to_spec(file : String) -> Spec raise {
  let json = @json.parse(file)
  @json.from_json(json)
}

///|
test "parse_file_to_spec" {
  let file =
    #|	{
    #|  "__ATTN__": "Do not edit this file; changes belong in the appropriate YAML file.",
    #|  "overview": "Comment tags represent content that should never appear in the resulting\noutput.\n\nThe tag's content may contain any substring (including newlines) EXCEPT the\nclosing delimiter.\n\nComment tags SHOULD be treated as standalone when appropriate.\n",
    #|  "tests": [
    #|    {
    #|      "name": "Inline",
    #|      "desc": "Comment blocks should be removed from the template.",
    #|      "data": {
    #|      },
    #|      "template": "12345{{! Comment Block! }}67890",
    #|      "expected": "1234567890"
    #|    },
    #|    {
    #|      "name": "Multiline",
    #|      "desc": "Multiline comments should be permitted.",
    #|      "data": {
    #|      },
    #|      "template": "12345{{!\n  This is a\n  multi-line comment...\n}}67890\n",
    #|      "expected": "1234567890\n"
    #|    },
    #|    {
    #|      "name": "Standalone",
    #|      "desc": "All standalone comment lines should be removed.",
    #|      "data": {
    #|      },
    #|      "template": "Begin.\n{{! Comment Block! }}\nEnd.\n",
    #|      "expected": "Begin.\nEnd.\n"
    #|    },
    #|    {
    #|      "name": "Indented Standalone",
    #|      "desc": "All standalone comment lines should be removed.",
    #|      "data": {
    #|      },
    #|      "template": "Begin.\n  {{! Indented Comment Block! }}\nEnd.\n",
    #|      "expected": "Begin.\nEnd.\n"
    #|    },
    #|    {
    #|      "name": "Standalone Line Endings",
    #|      "desc": "\"\\r\\n\" should be considered a newline for standalone tags.",
    #|      "data": {
    #|      },
    #|      "template": "|\r\n{{! Standalone Comment }}\r\n|",
    #|      "expected": "|\r\n|"
    #|    },
    #|    {
    #|      "name": "Standalone Without Previous Line",
    #|      "desc": "Standalone tags should not require a newline to precede them.",
    #|      "data": {
    #|      },
    #|      "template": "  {{! I'm Still Standalone }}\n!",
    #|      "expected": "!"
    #|    },
    #|    {
    #|      "name": "Standalone Without Newline",
    #|      "desc": "Standalone tags should not require a newline to follow them.",
    #|      "data": {
    #|      },
    #|      "template": "!\n  {{! I'm Still Standalone }}",
    #|      "expected": "!\n"
    #|    },
    #|    {
    #|      "name": "Multiline Standalone",
    #|      "desc": "All standalone comment lines should be removed.",
    #|      "data": {
    #|      },
    #|      "template": "Begin.\n{{!\nSomething's going on here...\n}}\nEnd.\n",
    #|      "expected": "Begin.\nEnd.\n"
    #|    },
    #|    {
    #|      "name": "Indented Multiline Standalone",
    #|      "desc": "All standalone comment lines should be removed.",
    #|      "data": {
    #|      },
    #|      "template": "Begin.\n  {{!\n    Something's going on here...\n  }}\nEnd.\n",
    #|      "expected": "Begin.\nEnd.\n"
    #|    },
    #|    {
    #|      "name": "Indented Inline",
    #|      "desc": "Inline comments should not strip whitespace",
    #|      "data": {
    #|      },
    #|      "template": "  12 {{! 34 }}\n",
    #|      "expected": "  12 \n"
    #|    },
    #|    {
    #|      "name": "Surrounding Whitespace",
    #|      "desc": "Comment removal should preserve surrounding whitespace.",
    #|      "data": {
    #|      },
    #|      "template": "12345 {{! Comment Block! }} 67890",
    #|      "expected": "12345  67890"
    #|    },
    #|    {
    #|      "name": "Variable Name Collision",
    #|      "desc": "Comments must never render, even if variable with same name exists.",
    #|      "data": {
    #|        "! comment": 1,
    #|        "! comment ": 2,
    #|        "!comment": 3,
    #|        "comment": 4
    #|      },
    #|      "template": "comments never show: >{{! comment }}<",
    #|      "expected": "comments never show: ><"
    #|    }
    #|  ]
    #|}
  let spec = parse_file_to_spec(file)
  assert_eq(spec.tests.length(), 12)
  assert_eq(spec.tests[0].name, "Inline")
  assert_eq(
    spec.tests[0].desc,
    "Comment blocks should be removed from the template.",
  )
  assert_eq(spec.tests[0].template, "12345{{! Comment Block! }}67890")
  assert_eq(spec.tests[0].expected, "1234567890")
  assert_eq(spec.tests[1].name, "Multiline")
  assert_eq(spec.tests[1].desc, "Multiline comments should be permitted.")
  assert_eq(
    spec.tests[1].template,
    "12345{{!\n  This is a\n  multi-line comment...\n}}67890\n",
  )
  assert_eq(spec.tests[1].expected, "1234567890\n")
}

///|
fn run_spec_test(self : SpecTest) -> Unit raise {
  let result = @lib.parse(self.template, self.data)
  assert_eq(
    result,
    self.expected,
    // msg="\{self.name}\n  actual=\{result}\n  want=\{self.expected}",
  )
}

///|
pub fn run_spec_tests(self : SpecFile) -> Unit raise {
  let failures = self.spec.tests.filter_map(fn(t) {
    let result = try? t.run_spec_test()
    match result {
      Ok(_) => None
      Err(e) => Some((t.name, e))
    }
  })
  if failures.is_empty() {
    return
  }
  let error_messages = failures
    .map(fn(f) {
      let (name, e) = f
      "Test '" + name + "' failed: " + e.to_string()
    })
    .join("\n")
  let error_message = "Some spec(\{self.name}) tests failed(\{failures.length()}/\{self.spec.tests.length()}):\n" + error_messages
  fail(error_message)
}
